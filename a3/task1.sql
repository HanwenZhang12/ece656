-- -----------------------------------------------------------------------------
--
-- ER Model Encoding
--
-- This does two things:
-- (1) The creation of the ER Model set of tables, together with their
--     constraints.  The set of constraints is imposed via
--     (a) Primary keys
--     (b) Foreign keys
--     (c) Triggers
--     (d) The addition of a foreign key after data is loaded
--         because the particular key is cyclic
-- (2) The insertion into this database of the ER Model for the portion
--     of the NHL database that describes the GamePlays model.
-- 
-- History
--  2 Mar 2023; PASW; Initial Drop

tee erModel.txt; -- help in debugging script

-- -----------------------------------------------------------------------------
--
-- Clean up tables, triggers, etc. before creation
--

-- Note name of FK is autogenerated; it must be this for first FK of the table.
-- MariaDB has an "if exists" version of this.  MySQL does not, so you may get
-- an error on this; the rest of this source code should work without error.

alter table EntitySets drop foreign key EntitySets_ibfk_1;

-- Get rid of the triggers
drop trigger if exists IsATrigger;
drop trigger if exists AttributesTrigger;
drop trigger if exists AttributeRangeTrigger;
drop trigger if exists ComponentAttributesTrigger;
drop trigger if exists AggregateEntitySetsTrigger;

-- Get rid of the tables
drop table if exists AttributeRange;
drop table if exists RelationshipAttributes;
drop table if exists ComponentAttributes;
drop table if exists Attributes;
drop table if exists Role;
drop table if exists RelationshipSetsBounds;
drop table if exists RelationshipSets;
drop table if exists IsA;
drop table if exists AggregateEntitySets;
drop table if exists WeakEntitySets;
drop table if exists EntitySets;

-- -----------------------------------------------------------------------------
--
-- Create the tables with primary keys, most foreign keys, and triggers
--

-- Entity sets tables

-- EntitySets() should have primaryKey as an FK to Attributes(attrName).
-- However, that creates a cyclic FK check.  Worse, this cannot be resolved
-- by entering the attribute data first, using NULL for the attribute's
-- associated entity set, and then updating it once the entity set data has
-- been input.  This is because the entity set in the Attributes relation is
-- part of the primary key of that relation, and so it cannot be NULL.  As
-- such we instead defer adding the FK from primaryKey to Attributes(attrName)
-- until after the data is input.

create table EntitySets(esName     varchar(50),
                        primaryKey varchar(50),
                        primary key (esName, primaryKey));

-- Because a weak entity set must be in a relationship, by definition, and
-- relationship sets will reference the EntitySets() relation, every weak
-- entity set must also be listed in EntitySets().  This also has the value
-- of ensuring that the primary key of the weak entity set is clearly
-- defined.

create table WeakEntitySets(weakES        varchar(50),
                            identifyingES varchar(50),
                            discriminator varchar(50),
                            primary key (weakES, discriminator),
                            foreign key (weakES)
                                    references EntitySets(esName)
                                    on update cascade
                                    on delete restrict,
                            foreign key (identifyingES)
                                    references EntitySets(esName));

-- Given that relationship sets could be spec'd entirely in
-- RelationshipSetsBounds(), this foreign key will not necessarily work.
-- Further, we cannot add the foreign key here because we haven't created
-- RelationshipSets yet.  Instead, we will add a trigger to do a check
-- against the pair or sets.
-- Trigger code comes after table-creation code.

create table AggregateEntitySets(rsName varchar(50),
                                primary key (rsName));
--                                foreign key (rsName)
--                                        references RelationshipSets(rsName));

-- Specialized entity sets do not have to be listed in EntitySets unless they
-- are in a relationship.  As such, we cannot use an FK reference to ensure
-- that the generalizedES is a valid entity set (it could, itself be a
-- specialized entity set, and not in EntitySets).  As such, we implement a
-- trigger to ensure that the generalizedES is in one of IsA(specializedES)
-- or in EntitySets(esName).  We do not need to check either WeakEntitySets
-- or AggregateEntitySets since both of those are listed in EntitySets.
-- The trigger code is listed after the table creation code.

create table IsA(specializedES  varchar(50) primary key,
                 generalizedES  varchar(50),
                 disjoint       boolean,
                 total          boolean); 

-- -----------------------------------------------------------------------------
--
-- Relationship sets tables
--
-- Any entity set in a relationship MUST be listed in EntitySets
--

create table RelationshipSets(rsName varchar(50),
                              esName varchar(50),
                              lower  char(1),
                              upper  char(1),
                              primary key (rsName, esName),
                              foreign key (esName) references EntitySets(esName));
                              
create table RelationshipSetsBounds(rsName    varchar(50),
                                    esName    varchar(50),
                                    wrtESName varchar(50),
                                    lower     char(1),
                                    upper     char(1),
                                    primary key (rsName, esName, wrtESName),
                                    foreign key (esName) references EntitySets(esName),
                                    foreign key (wrtESName) references EntitySets(esName));
                                    
-- Technically a role could occur with a relationship listed only in
-- RelationshipSetsBounds.  We're going to ignore that case for now

create table Role(rsName varchar(50),
                  esName varchar(50),
                  role   varchar(50),
                  primary key (esName, role),
                  foreign key (esName) references EntitySets(esName),
                  foreign key (rsName) references RelationshipSets(rsName));

-- -----------------------------------------------------------------------------
--
-- Attributes tables
--
-- Because attribute names are not guaranteed to be unique, and this is
-- even unlikely with component attributes of composites (see "type" in
-- GamePlays), we need to add a per-entity-set identifier to code the
-- tree of attributes.
-- Entity sets can also form a tree, per the IsA hierarchy.  However, this
-- problem does not happen there because entity set names MUST be unique
-- across the model.
--
-- Attributes must come from entity sets.  While all weak and aggregate
-- entity sets are also recorded in EntitySets, those in IsA are not.  As
-- such we cannot use an FK to enforce the validity of esName and so we
-- use a trigger instead.
-- Attributes form a tree with the attribute names not being unique.  As such,
-- each attribute is given an identifier, which is simply its number within
-- the entity set for which it is an attribute (See ComponentAttributes below).
-- Code for the trigger is after table creation.

create table Attributes(attrName    varchar(50),
                        esName      varchar(50),
                        multivalued boolean,
                        idInES      int,                  -- Needed to code tree
                        primary key (attrName, idInES, esName));

-- Component attributes must reference their parent.  While this could just be
-- the compositeID (it cannot be just the name, per lack of uniqueness), we
-- require both because the ID will be easier to get wrong; the name is more
-- likely correct.
-- We would like to do an FK check, but cannot because both relationship
-- attributes and entity-set attributes can be composite.  As such, we need
-- to do this as a trigger on insert (and update and delete if we really
-- want to be complete).  This is OK, though, because we need a trigger
-- anyway to ensure that both composite and component are in same entity set
-- (or relationship set, as the case may be).
-- The code for this trigger is after the table creation code

create table ComponentAttributes(componentAttrName varchar(50),
                                 componentAttrID   int,
                                 compositeName     varchar(50),
                                 compositeID       int,
                                 primary key (componentAttrName, compositeName));

-- Relationship attributes should be associated with a relationship set.
-- It is possible that the rsName is only within RelationshipSetsBounds.
-- We're going to assume that won't happen and just have an FK to
-- RelationshipSets.

create table RelationshipAttributes(rsAttrName  varchar(50),
                                    rsName      varchar(50),
                                    multivalued boolean,
                        						idInRS      int,      -- Needed to code tree
                                    primary key (rsAttrName, rsName),
																		foreign key (rsName)
																						references RelationshipSets(rsName));

-- AttributeRange() is like ComponentAttributes, applying to both entity-set
-- attributes and relationship-set attributes.  As such, we need the
-- "attrName, esName" attribute pair to be "FK-like" to either
-- Attributes(attrName, esName) or to
-- RelationshipAttributes(rsAttrName, rsName).
-- This is implemented as a trigger below.

create table AttributeRange(attrName varchar(50),
                            esName   varchar(50),
                            lower    char(1),
                            upper    char(1),
                            primary key (attrName, esName));

-- ----------------- START OF TRIGGER CODE -------------------------------------
--
-- Trigger Code, per comments about
--
-- Note that for each trigger code we change and then revert the delimiter.
-- While it would be possible to simply change it at the start and undo that
-- change at the end, we do not do so because
-- (a) The code in question is trivial and not distracting
--     (it could easily be reworded as "start trigger" and "end trigger")
-- (b) The delineation of the trigger is helpful
-- (c) It makes it less likely for someone to accidently remove a whole
--     trigger and take one of those delimiter change statements away.
--
-- We only create triggers for insert operations; we should include them
-- for update and delete, but this is sufficient for illustrative purposes
-- and is all of the trigger code required for the assignment
--
-- We only describe the trigger design for the first trigger.

-- -----------------------------------------------------------------------------
-- IsATrigger to ensure generalizedES is in either
-- IsA(specializedES) or
-- EntitySets(esName)
--
-- Basic technique: find out if generalizedES of row being inserted is in
--                  ((select esName from EntitySets where esName='...') union all
--                   (select specializedES from IsA where specializedES='...')
-- If it is NOT in there, we reject the insert operation.
-- Design choices:
-- (1) We could have performed a union first and then check for membership.
--     This is a bad choice because the union will not have an index; by doing
--     separate membership checks we find the matches (and there will be only
--     a single match or no matches at all (technically, there could be more
--     than one match, but the distinct means the optimizer will leave stop
--     on first match found), and so the union is incredibly cheap.
-- (2) We use "select 1" because we don't care what the row is; only its
-- 		 existence.  Similarly, by saying "distinct 1" we tell the optimizer
--		 that first match is sufficient.
-- (3) "Union all" means there is no attempt to remove duplicates.
-- (4) Both sets must be empty for the "not exists" to be true.


delimiter @@                      
create trigger IsATrigger before insert on IsA for each row
begin
if not exists ((select distinct 1 from EntitySets where esName = new.generalizedES)
              union all
               (select distinct 1 from IsA where specializedES = new.generalizedES)) then
signal sqlstate '45000'
    set message_text = 'Attempt to insert specializedES where generalizedES does not exist';
end if;
end; @@
delimiter ;

-- -----------------------------------------------------------------------------
-- AttributesTrigger to ensure esName is in either
-- IsA(specializedES) or
-- EntitySets(esName)

delimiter @@                      
create trigger AttributesTrigger before insert on Attributes for each row
begin
if not exists ((select distinct 1 from EntitySets where esName = new.esName)
              union all
               (select distinct 1 from IsA where specializedES = new.esName)) then
signal sqlstate '45000'
    set message_text = 'Attempt to insert attribute where esName does not exist';
end if;
end; @@
delimiter ;

-- -----------------------------------------------------------------------------
-- AttributeRangeTrigger to ensure (attrName,esName) is in either
-- Attributes(attrName, esName) or
-- RelationshipAttributes(rsAttrName, rsName)

delimiter @@                      
create trigger AttributeRangeTrigger before insert on AttributeRange for each row
begin
if not exists ((select distinct 1 from Attributes
	 		 								 where Attributes.esName   = new.esName
	 		 								 	 and Attributes.attrName = new.attrName)
              union all
               (select distinct 1 from RelationshipAttributes
	 		 								 where RelationshipAttributes.rsName     = new.esName
	 		 								 	 and RelationshipAttributes.rsAttrName = new.attrName)) then
signal sqlstate '45000'
    set message_text = 'Attempt to insert attribute range where attribute does not exist';
end if;
end; @@
delimiter ;

-- -----------------------------------------------------------------------------
-- ComponentAttributesTrigger to ensure that both the component and composite
-- are in either
-- Attributes (i.e., they are both attributes of an entity set)
-- or in
-- RelationshipAttributes (i.e., they are both attributes of a relationship)
-- and in either case ensures that both are in the SAME entity/relationship set

delimiter @@                      
create trigger ComponentAttributesTrigger before insert on ComponentAttributes for each row
begin
if not exists (
   (select 1 from  ((select distinct esName from Attributes
                            where attrName = new.componentAttrName
                              and idInES   = new.componentAttrID) as cANP
          inner join                                     
                    (select distinct esName from Attributes
                            where attrName = new.compositeName
                              and idInES   = new.compositeID) as cNP
          using (esName)))
	  union all
   (select 1 from  ((select distinct rsName from RelationshipAttributes
                            where rsAttrName = new.componentAttrName
                              and idInRS     = new.componentAttrID) as cANP
          inner join                                     
                    (select distinct rsName from RelationshipAttributes
                            where rsAttrName = new.compositeName
                              and idInRS     = new.compositeID) as cNP
          using (rsName)))
	 ) then
signal sqlstate '45000'
    set message_text = 'Attempt to insert component attribute where composite does not exist';
end if;
end; @@
delimiter ;

-- -----------------------------------------------------------------------------
-- AggregateEntitySetsTrigger to ensure rsName is in either
-- RelationshipSets(rsName) or
-- RelationshipSetsBounds(rsName)

delimiter @@                      
create trigger AggregateEntitySetsTrigger before insert on AggregateEntitySets for each row
begin
if not exists ((select distinct 1 from RelationshipSets
                       where RelationshipSets.rsName = new.rsName)
              union all
               (select distinct 1 from RelationshipSetsBounds
                       where RelationshipSetsBounds.rsName = new.rsName)) then
signal sqlstate '45000'
    set message_text = 'Attempt to create aggregate entity set where relationship set does not exist';
end if;
end; @@
delimiter ;

-- ----------------- END OF TRIGGER CODE ---------------------------------------

-- ----------------- START OF GamePlays ER Model INSERT STATEMENTS -------------
-- Populate entity sets first

insert into EntitySets values
            ('Game', 'gameID'),
            ('TeamInfo', 'teamID'),
            ('PlayerInfo', 'playerID'),
            ('GamePlays', 'gameID'),       -- Primary key for GamePlays is
            ('GamePlays', 'playNumber');   -- gameID and playNumber
                                           
insert into WeakEntitySets values
            ('GamePlays', 'Game', 'playNumber');

insert into IsA values
			('NonExecutablePlays', 'GamePlays', true, true),
            ('ExecutablePlays', 'GamePlays', true, true),
            ('OfficialChallenges', 'GamePlays', true, true),
            ('GameShots', 'ExecutablePlays', true, false),
            ('GamePenalties', 'ExecutablePlays', true, false),
            ('GameGoals', 'ExecutablePlays', true, false);

-- Then relationship sets

insert into RelationshipSets values
            ('GamePlaysPlayers', 'Game', '0', '*'),
            ('GamePlaysPlayers', 'ExecutablePlays', '0', '1'),
            ('GamePlaysPlayers', 'TeamInfo', '0', '*'),
            ('GamePlaysPlayers', 'PlayerInfo', '0', '*'),
            ('GamePlaysPlayers2', 'Game', '0', '*'),
            ('GamePlaysPlayers2', 'OfficialChallenges', '0', '1'),
            ('GamePlaysPlayers2', 'TeamInfo', '0', '*'),
            ('GamePlaysPlayers2', 'PlayerInfo', '0', '*');

insert into Role values
            ('GamePlaysPlayers', 'TeamInfo', 'teamFor'), 
            ('GamePlaysPlayers', 'TeamInfo', 'teamAgainst'),
            ('GamePlaysPlayers2', 'TeamInfo', 'teamFor'), 
            ('GamePlaysPlayers2', 'TeamInfo', 'teamAgainst'); 

-- And finish with the attributes

insert into Attributes values
            ('playNumber',    'GamePlays', false, 1),
            ('dateTime',      'GamePlays', false, 2),
            ('period',        'GamePlays', false, 6),
            ('type',          'GamePlays', false, 7), -- period type, not play type
            ('number',        'GamePlays', false, 8),
            ('time',          'GamePlays', false, 9),
            ('timeRemaining', 'GamePlays', false, 10),
            ('description',   'GamePlays', false, 17),
            
            ('gameID',   'Game',       false, 1),
            ('gameType', 'Game',       false, 2),
            
            ('teamID',   'TeamInfo',   false, 1),
            
            ('playerID', 'PlayerInfo', false, 1);
            
insert into RelationshipAttributes values
            ('playerRole', 'GamePlaysPlayers', true, 1),
            ('playerRole', 'GamePlaysPlayers2', true, 1);

-- ----------------- END OF GamePlays ER Model INSERT STATEMENTS ---------------

-- ----------------- ADD FINAL FOREIGN KEYS ------------------------------------

alter table EntitySets add foreign key (primaryKey) references Attributes(attrName);

-- Done
notee;
-- ----------------- END OF CODE -----------------------------------------------

